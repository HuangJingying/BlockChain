// {type: class}
// {generate: true}
[BigInt|-number:vector<uint64_t> // 储存大数，逆序存储，每64位为一个块; -bit:int // 数位;-inverseComputed:bool // 是否求逆(用于乘方运算);-numberInverse:vector<uint64_t> // 储存求逆后的大数(用于乘方运算);/*以下定义几个常用数*/</u>;+zero:BigInt*</u>;<u>+one:BigInt</u>;<u>+two:BigInt</u>|<u>+Shrink(vec,vector<uint64_t>):int // 进位函数，同时去掉末尾的0，返回位数</u>;/*以下定义默认构造函数，复制构造函数，用字符串初始化的构造函数，用向量初始化的构造函数，用整数初始化的构造函数*/;+BigInt();+BigInt(bigInt:BigInt &);+BigInt(s:string);+BigInt(x:int &);+ToString():string // 将大数转换为字符串;/*下面重载大数相关的运算符*/;+>>(input:istream &, bigInt:BigInt &):istream &;+<<(output : ostream &, bigInt:BigInt &);+!=(bigInt:BigInt):bool;+==(bigInt:BigInt):bool;+<(bigInt:BigInt):bool;+>(bigInt:BigInt):bool;+<=(bigInt:BigInt):bool:+>=(bigInt:BigInt):bool;++=(bigInt:BigInt &):BigInt &;++(bigInt:BigInt &):BigInt;+-=(bigInt:BigInt &):BigInt &;+-(bigInt:BigInt &):BigInt;+*=(bigInt:BigInt &):BigInt&;+*(bigInt:BigInt &):BigInt;+/=(bigInt:BigInt &):BigInt &;+/(bigInt:BigInt &):BigInt;+%(bigInt):BigInt;+%=(bigInt:BigInt &):BigInt &;<u>+PowMod(a:BigInt &, e:BigInt &, mod:BigInt &):BigInt // a ^ e % n</u>;<u>+ToInt(s:string):BigInt // 将字符串转为大数</u>;-GetBit():int // 返回大数的位数;-DecToBin(s:string):string // 将输入的十进制串转为二进制串;-SetBin(s:string):void // 用二进制串构造大数;-DivMod(_a:BigInt &, _b:BigInt &):pair<BigInt, BigInt> // 带余除法，数对前一项为商后一项为余数;-GetResidualWithInverse(a:BigInt &, inv:BigInt &):BigInt // 计算定点逆(用于乘方运算);-Reverse(length:int):BigInt // 翻转大数(用于乘方运算);-RightShift(length:int):BigInt // 返回右移后的大数(用于乘方运算);-ComputeInverse():void // 计算大数的逆(用于乘方运算);]
[Block|-version:int//当前版本号;-preBlockHash:string // 前一个区块的哈希;-merkleRoot:string // 梅克尔树树根哈希值;-time:time_t // 时间戳;-diffcultyTarget:string // 难度值;-height:int // 高度;-nonce:int // 工作量证明常数;-numTransactions:uint64_int // 区块中的交易数量;-merkleTreeRoot:node* //梅克尔树树根指针;-merkleTree:vector<node*> // 梅克尔树指针;+preBlock:Block* // 上一个区块指针|+Pack():void // 将通过验证的区块打包进区块链;+Block() // 默认构造函; +Block(_nonce:int, difficulty:string, vec:vector<Transaction> &) // 构造函数; +Block(p:Block &) // 复制构造函数;+SetDifficultyTarget(difficulty:string):void // 设置难度值;+SetNonce(_nonce:int):void // 设置工作量证明常数;+GetHeight():int // 获得高度; +GetHash():string // 获得区块哈希值;+Show():void // 打印区块信息;+AddTransactionSet(add:vector<Transaction> &):bool // 向区块中添加交易，若成功返回true;+GetTransactionSet(result:vector<Transaction> &):bool // 获得区块内的交易，若成功返回true;+<u>CreateTree(vec:vector<Transaction> &):bool // 根据交易构造梅克尔树</u>;+CreateTreeCheck():pair<bool, node*> // 检查梅克尔树与交易是否一致，若不一致返回false与出错交易(假设只有一处出错);+GetTreeRoot():string // 获得树根哈希值;+GetTreeRootpt():node* // 获得树根指针;+ShowTree():void // 打印梅克尔树信息]->[<<Struct>>;node|+id:int // 节点编号;+transactionHash:string // 交易哈希值;+leftTree:node* // 左子树指针;+rightTree // 右子树指针;+father:node* // 父节点指针]
[Chain|-difficulty:string // 区块链的难度值;-end:Block* // 区块链尾区块指针;-blocks:vector<Block> // 区块链中的区块|+Chain() // 默认构造函数;+Chain(p:Chain &) // 复制构造函数;+GetLastBlock():Block* // 获得最后一个区块指针;+AddBlock(newBlock:Block*):void // 添加一个区块;+SetDifficulty(difficultyTarget:string):void // 设置所有矿工的难度值;+GetDifficulty:string // 获得难度值;<u>GetCoinBaseIndex():string // 获得创始区块地址</u>;+GetTransaction():vector<Transaction> // 获得区块链中的所有交易;Print():void // 打印区块链]<>-blocks>[Block]
[Block]-end>[Chain]
[Miner|#nonce:int // 工作量证明常数;#difficultyTarget:string // 难度值;<u>+minerSet:Miner* // 网络中所有矿工</u>;#stored:Block // 矿工暂存的区块|+Miner(worker:int) // 构造函数(生成地址);+Miner() // 默认构造函数(不生成地址);+Miner(p:Miner &) // 复制构造函数;+Init(worker:int):void // 地址生成器;+InitPrint():void // 生成信息打印;+Reset():void // 重置矿工挖矿进度;+Check(toCheck:Block &):bool // 检查区块是否正确;+TestPoW(nonce:int):bool // 检查工作量证明常数是否合法;+PoW():void // 工作量证明;+GetNonce():int // 获得工作量证明常数;+Load(vec:vector<Transaction> &):void // 装载交易;+GetBlock():Block // 获得暂存的区块;+SetNonce(_nonce:int):void // 设置工作量证明常数;SetDifficulty(_diffucltyTarget:string):void / 设置难度值;+ShowDifficulty():void // 获得难度值]<>-stored>[Block]
[Miner]-.-minerSet>[Miner]
[RSA|-publicKey:BigInt // 公钥;-pricateKey:BigInt // 私钥;-Euler:BigInt // 欧拉函数;-product:BigInt // 乘积;-p:BigInt // 一个质数;-q:BigInt // 另一个质数|+RSA() // 默认构造函数;+Init(worker:int):void // 初始化(原本使用多线程但会造成速度减慢因此残留有线程数参数);+CreatePrime(worker:int):BigInt // 寻找质数;+CreateRandom(int):BigInt // 构造随机数;+Extgcd(BigInt, BigInt, BigInt &):void // 扩展欧几里得算法;+CreateKeys():void // 构造公钥私钥;+CreateRandomSmaller(BigInt &):BigInt // 寻找更小的随机数(用于MR检验);+EncryptByPulic(BigInt &):BigInt // 公钥加密;EncryptByPrivate(BigInt &):BigInt // 私钥加密;+DecryptByPublic(BigInt &):BigInt // 公钥解密;+DecryptByPrivate(BigInt &):BigInt // 私钥解密;+EncryptAndDecrypt(BigInt &, BigInt &, BigInt &):BigInt // 检验加密解密正确性;+IsPrime(BigInt &, k:int=4):int // MR算法判断是否为质数;+Sieve(vecotr<BigInt>, BigInt &, int):int // 用小质数过筛法]p, q, Euler, product, publicKey, privateKey-.->[BigInt]
[Transaction|+txID:int // 交易编号;+_time:time_t // 时间戳;+intput:TxInput // 交易输入;+output:TxOutput // 交易输出;+senderAdr:string // 发出者地址;+receiverAdr:string // 接收者地址;<u>+mineReward:int // 挖矿收益</u>;<u>+cnt:int // 交易总数量</u>;<u>+txPool:vector<Transaction> // 交易池;<u>+toBePackedTx:vector<Transaction> // 待打包交易;<u>+packedTx:vector<Transaction> // 已打包交易|+Transaction(_sender:string, _receiverAdr:string) // 构造函数(非奖励交易);+Transaction(_receiverAdr:string) // 构造函数(奖励交易);+Show():void // 打印交易信息;+SetID():void // 设置交易编号;+IsCoinbase():bool // 判断是否为系统奖励交易;+GetID():int // 获得编号;+GetTxHash():string // 获得交易哈希]
[Transaction]-.-toBePackedTx, txPool, packedTx>[Transaction]
[TxInput|-prevID:int // 前一项编号;-value:int // 交易金额;+signature:BigInt // 交易签名;+publicKey:BigInt // 发送方公钥;+N:BigInt // 发送方的质数乘积|+TxInput(_value:int, _publicKey:BigInt, _N:BigInt) // 构造函数;+TxInput() // 默认构造函数;+GetPrevID():int // 获得前一笔交易编号;+GetValue():int // 获得交易金额;SetPrevID(ID:int):void // 设置上一笔交易编号]-.-signature, publicKey, N>[BigInt]
[TxOutput|-value:int // 交易金额;-publicHash:string // 接收方公钥哈希|+TxOutput() // 默认构造函数;+TxOutput(_value:int, _receiverPublicHash:string) // 构造函数;+GetPublicHash():string // 获得公钥哈希;+GetValue():int // 获得交易金额]
[Wallet|#publicKeyHash:string // 公钥哈希;#address:string // 地址;#version:string // 版本号;#privateKey:BigInt // 私钥;#publicKey:BigInt // 公钥;#n:BigInt // 大数乘积;#chain:Chain // 保存的区块链;<u>+walletInfo:vector<pair<string, string>> // 钱包信息(前一项为地址，后一项为公钥哈希)</u>;<u>+walletSet:vector<Wallet> // 钱包集合</u>;<u>+onlyWalletSet:vector<Wallet> // 除去矿工的钱包集合(矿工也在钱包集合中)</u>|+Wallet(worker:int) // 构造函数(生成公钥私钥);+Wallet() // 默认构造函数(暂用钱包不生成公钥私钥，不进入集合);+Init(worker:int):void // 生成公钥私钥(虚函数);+InitPrint():void // 打印初始化信息(虚函数);+GetKey():turple<BigInt, BigInt, string> // 获得公钥私钥;+GetAddress():string // 获得地址;+SetWallet(_publicKey:BigInt, _privatekey:BigInt, _N: BigInt, _addr:string):void // 设置钱包;+CheckChain():bool // 检查区块链是否正确，若不正确返回错误交易信息;+CreateTransaction(receiverInfo:pair<string, string>, _value:int):bool // 创建交易，若创建成功返回true;+CreateCoinbase(x:int):void // 创建自定义金额的系统奖励交易;+CreateCoinbase():void / 创建默认的系统奖励交易;+Sign(tx:Transaction &, receiverPublicKeyHash:string, val:int):void // 签名;+FindSpent(pool:vector<Transaction &>):vector<int> // 寻找与钱包相关联的UXTO;+FindUTXO(spentTxId:vector<int> &, pool:vector<Transaction> &):vector<Transaction> // 选择可用UTXO;+FindBalance():int* // 查询余额;+GetChain():Chain // 获得存储的区块链;+SetChain(newChain:Chain &):void // 设置区块链; <u>+VerifyTx(_tx:Transaction &):bool // 检验交易正确性]-.-pricateKey, publicKey, n>[BigInt]
[Wallet]^[Miner]
[Block]<>->[Transaction]
[Transaction]++-[TxInput]
[Transaction]++-[TxOutput]
[BigInt]<>zero, one, two->[BigInt]
[<<Struct>>;node]-leftTree, rightTree, father>[<<Struct>>;node]
[Wallet]-.-chain>[Chain]
[Wallet]<>-onlyWalletSet, walletSet>[Wallet]